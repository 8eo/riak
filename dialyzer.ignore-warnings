###
### This is not a comment, just a pattern that is
### very unlikely to match anything that we care about.
### Don't put blank lines in this file.
###
### Items that can be ignored because of EUnit macros doing odd
### things or Dialyzer not finding erlang:load_nif/2 (which definitely exists).
###
Call to missing or unexported function erlang:load_nif/2
The variable _ can never match since previous clauses completely covered the type 'false'
Contract for function that does not exist: riak_client:for_dialyzer_only_ignore/2
riak_core_ring_manager.erl:324: Call to missing or unexported function riak_core_test_util:setup_mockring1/0
riak_kv_delete.erl:107: The pattern 'true' can never match the type 'false'
###
### Items in third-party code that are harmless enough
###
js_mochijson2.erl:530: The variable __V can never match since previous clauses completely covered the type 'true'
mochijson2.erl:530: The variable __V can never match since previous clauses completely covered the type 'true'
mochiweb_request.erl:246: The variable Length can never match since previous clauses completely covered the type 'chunked' | 'undefined' | integer() | {'unknown_transfer_encoding',_}
mochiweb_request.erl:271: The call mochiweb:new_response({{_,port() | {'ssl',{'sslsocket',_,_}},_,_,_,_},binary() | maybe_improper_list() | integer(),gb_tree()}) contains an opaque term as 1st argument when a structured term of type {_,_,[any()] | tuple()} is expected
mochiweb_socket_server.erl:128: The call erlang:integer_to_list(S::maybe_improper_list()) will never return since it differs in the 1st argument from the success typing arguments: (integer())
mochiweb_sup.erl:26: The pattern [Spec | _] can never match the type []
meck.erl:653: The pattern <Mod, Func, Args, [Meck = {'meck', 'exec', _Arity} | Stack]> can never match the type <atom(),_,_,[{atom(),atom(),[any()] | byte(),[any()]},...]>
meck_cover.erl:30: Call to missing or unexported function cover:compile_beam/2
meck_cover.erl:98: Call to missing or unexported function cover:get_term/1
meck_cover.erl:109: Call to missing or unexported function cover:write/2
watchdog.erl:272: The call lists:keyreplace(Key::{'log' | 'pid' | 'tcp' | 'udp' | integer(),_},1,Subs::maybe_improper_list(),Sub::fun((_) -> any())) will never return since it differs in the 4th argument from the success typing arguments: (any(),pos_integer(),maybe_improper_list(),tuple())
sherk.erl:426: Function init_tree_view_cols/1 will never be called
sherk.erl:427: Function will never be called
sherk.erl:429: Function init_tree_view_col/2 will never be called
sherk.erl:445: Function init_list_store/1 will never be called
sherk.erl:468: Function init_combobox/1 will never be called
sherk.erl:479: Function init_tree_store/1 will never be called
sherk.erl:522: Function set_selection_mode/2 will never be called
supervisor_pre_r14b04.erl:1250: The call erlang:length('undefined' | pid()) will never return since it differs in the 1st argument from the success typing arguments: ([any()])
erlydtl_runtime.erl:27: The call gb_trees:lookup(Key::any(),{integer(),_}) does not have an opaque term of type gb_tree() as 2nd argument
erlydtl_runtime.erl:37: The call dict:find(Key::any(),Tuple::tuple()) does not have an opaque term of type dict() as 2nd argument
erlydtl_dateformat.erl:345: The variable _ can never match since previous clauses completely covered the type 1 | 2 | 3 | 4 | 5 | 6 | 7
i18n_manager.erl:22: The pattern {'ok', SplittedLocales} can never match the type [nonempty_string()]
i18n_manager.erl:73: Function close_tables/1 will never be called
i18n_manager.erl:81: Function dets_data/0 will never be called
i18n_manager.erl:82: Function dets_fuzzy/0 will never be called
i18n_manager.erl:84: Function insert_tokens/1 will never be called
i18n_manager.erl:89: Function insert_token/4 will never be called
i18n_manager.erl:94: Function insert_translations/1 will never be called
i18n_manager.erl:107: Function insert_translation/2 will never be called
i18n_manager.erl:124: Function get_file_info/1 will never be called
### 
### Warnings from auto-generated protobufs code.  Hard/not-worth-it-now to fix.
yeccpre.hrl:49: Function return_error/2 will never be called
leexinc.hrl:49: The pattern <Rest, Line, {'token', T, Push}, Ts> can never match the type <_,_,'error' | 'skip_token',[{atom(),_} | {'float',_,float()} | {'integer',_,[any()] | integer()} | {'string',_,[any()]} | {'var',_,atom()}]>
leexinc.hrl:52: The pattern <Rest, Line, {'end_token', T}, Ts> can never match the type <_,_,'error' | 'skip_token',[{atom(),_} | {'float',_,float()} | {'integer',_,[any()] | integer()} | {'string',_,[any()]} | {'var',_,atom()}]>
leexinc.hrl:54: The pattern <Rest, Line, {'end_token', T, Push}, Ts> can never match the type <_,_,'error' | 'skip_token',[{atom(),_} | {'float',_,float()} | {'integer',_,[any()] | integer()} | {'string',_,[any()]} | {'var',_,atom()}]>
leexinc.hrl:59: The pattern <Rest, Line, {'skip_token', Push}, Ts> can never match the type <_,_,'error',[{atom(),_} | {'float',_,float()} | {'integer',_,[any()] | integer()} | {'string',_,[any()]} | {'var',_,atom()}]>
leexinc.hrl:62: The pattern <_Rest, Line, {'error', S}, _Ts> can never match the type <_,_,'error',[{atom(),_} | {'float',_,float()} | {'integer',_,[any()] | integer()} | {'string',_,[any()]} | {'var',_,atom()}]>
leexinc.hrl:118: The pattern <Rest, Line, {'token', T, Push}> can never match the type <_,_,'error' | 'skip_token'>
leexinc.hrl:121: The pattern <Rest, Line, {'end_token', T}> can never match the type <_,_,'error' | 'skip_token'>
leexinc.hrl:123: The pattern <Rest, Line, {'end_token', T, Push}> can never match the type <_,_,'error' | 'skip_token'>
leexinc.hrl:128: The pattern <Rest, Line, {'skip_token', Push}> can never match the type <_,_,'error'>
leexinc.hrl:131: The pattern <Rest, Line, {'error', S}> can never match the type <_,_,'error'>
leexinc.hrl:192: The pattern <Rest, Line, {'token', T, Push}, Ts> can never match the type <_,_,'error' | 'skip_token',_>
leexinc.hrl:195: The pattern <Rest, Line, {'end_token', T}, Ts> can never match the type <_,_,'error' | 'skip_token',_>
leexinc.hrl:197: The pattern <Rest, Line, {'end_token', T, Push}, Ts> can never match the type <_,_,'error' | 'skip_token',_>
leexinc.hrl:202: The pattern <Rest, Line, {'skip_token', Push}, Ts> can never match the type <_,_,'error',_>
leexinc.hrl:205: The pattern <Rest, Line, {'error', S}, _Ts> can never match the type <_,_,'error',_>
leexinc.hrl:243: The pattern <Rest, Line, {'token', _T, Push}, Error> can never match the type <_,_,'error' | 'skip_token',_>
leexinc.hrl:246: The pattern <Rest, Line, {'end_token', _T}, Error> can never match the type <_,_,'error' | 'skip_token',_>
leexinc.hrl:248: The pattern <Rest, Line, {'end_token', _T, Push}, Error> can never match the type <_,_,'error' | 'skip_token',_>
leexinc.hrl:253: The pattern <Rest, Line, {'skip_token', Push}, Error> can never match the type <_,_,'error',_>
leexinc.hrl:256: The pattern <Rest, Line, {'error', _S}, Error> can never match the type <_,_,'error',_>
leexinc.hrl:260: Function yyrev/2 will never be called
pokemon_pb.erl:46: The variable _ can never match since previous clauses completely covered the type #pikachu{}
pokemon_pb.erl:52: The pattern <Default, _> can never match since previous clauses completely covered the type <_,'none'>
pokemon_pb.erl:53: The pattern <Val, _> can never match since previous clauses completely covered the type <_,'none'>
prfTarg.erl:21: The pattern 'underfined' can never match the type 'undefined' | pid() | port()
protobuffs.erl:373: Invalid type specification for function protobuffs:encode_field_tag/2. The success typing is (non_neg_integer(),0 | 1 | 2 | 5) -> [integer(),...]
protobuffs.erl:387: Invalid type specification for function protobuffs:encode_varint/1. The success typing is (integer()) -> [integer(),...]
protobuffs.erl:393: Invalid type specification for function protobuffs:encode_varint/2. The success typing is (integer(),[integer()]) -> [integer(),...]
protobuffs_compile.erl:707: Function find_extended_msg/2 will never be called
protobuffs_compile.erl:710: Function will never be called
protobuffs_compile.erl:714: Function will never be called
protobuffs_compile.erl:722: Function find_defined_extensions/2 will never be called
protobuffs_compile.erl:725: Function will never be called
protobuffs_compile.erl:729: Function will never be called
riak_pb.erl:52: The pattern <Default, _> can never match since previous clauses completely covered the type <_,'none'>
riak_pb.erl:53: The pattern <Val, _> can never match since previous clauses completely covered the type <_,'none'>
riak_pb.erl:57: The pattern <_, 'repeated', 'undefined', _, _> can never match the type <1 | 2,'optional' | 'required',_,'bytes' | 'uint32',[]>
riak_pb.erl:59: The pattern <_, 'repeated_packed', 'undefined', _, _> can never match the type <1 | 2,'optional' | 'required',_,'bytes' | 'uint32',[]>
riak_pb.erl:60: The pattern <_, 'repeated_packed', [], _, _> can never match the type <1 | 2,'optional' | 'required',_,'bytes' | 'uint32',[]>
riak_pb.erl:65: The pattern <_, 'repeated', [], _, Acc> can never match the type <1 | 2,'optional' | 'required',_,'bytes' | 'uint32',[]>
riak_pb.erl:68: The pattern <FNum, 'repeated', [Head | Tail], Type, Acc> can never match the type <1 | 2,'optional' | 'required',_,'bytes' | 'uint32',[]>
riak_pb.erl:71: The pattern <FNum, 'repeated_packed', Data, Type, _> can never match the type <1 | 2,'optional' | 'required',_,'bytes' | 'uint32',[]>
riak_pb.erl:86: The call riak_pb:enum_to_int(Type::'bytes' | 'uint32',Data::atom()) will never return since it differs in the 1st argument from the success typing arguments: ('pikachu','value')
riak_pb.erl:88: The pattern <'pikachu', 'value'> can never match the type <'bytes' | 'uint32',atom()>
riak_pb.erl:111: The pattern 'true' can never match the type 'false'
riak_pb.erl:117: The pattern 'true' can never match the type 'false'
riak_pb.erl:126: The pattern 'true' can never match the type 'false'
riak_pb.erl:138: The pattern {_, _, Dict} can never match the type 'false'
riak_pb.erl:151: The pattern <Binary, 'string'> can never match the type <'-infinity' | 'false' | 'infinity' | 'nan' | 'true' | binary() | [integer()] | number(),'bytes' | 'uint32'>
riak_pb.erl:171: The pattern <Types, [{Fnum, Bytes} | Tail], Acc> can never match the type <_,[],[{_,_}]>
riak_kv_pb.erl:52: The pattern <Default, _> can never match since previous clauses completely covered the type <_,'none'>
riak_kv_pb.erl:53: The pattern <Val, _> can never match since previous clauses completely covered the type <_,'none'>
riak_kv_pb.erl:59: The pattern <_, 'repeated_packed', 'undefined', _, _> can never match the type <1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11,'optional' | 'repeated' | 'required',_,'bool' | 'bytes' | 'rpbbucketprops' | 'rpbcontent' | 'rpbindexreq_indexquerytype' | 'rpblink' | 'rpbpair' | 'uint32',[[binary() | maybe_improper_list(any(),binary() | [])]]>
riak_kv_pb.erl:60: The pattern <_, 'repeated_packed', [], _, _> can never match the type <1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11,'optional' | 'repeated' | 'required',_,'bool' | 'bytes' | 'rpbbucketprops' | 'rpbcontent' | 'rpbindexreq_indexquerytype' | 'rpblink' | 'rpbpair' | 'uint32',[[binary() | maybe_improper_list(any(),binary() | [])]]>
riak_kv_pb.erl:71: The pattern <FNum, 'repeated_packed', Data, Type, _> can never match the type <1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11,'optional' | 'repeated' | 'required',_,'bool' | 'bytes' | 'rpbbucketprops' | 'rpbcontent' | 'rpbindexreq_indexquerytype' | 'rpblink' | 'rpbpair' | 'uint32',[[binary() | maybe_improper_list(any(),binary() | [])]]>
riak_kv_pb.erl:151: The pattern <Binary, 'string'> can never match the type <'-infinity' | 'false' | 'infinity' | 'nan' | 'true' | binary() | [integer()] | number(),'bool' | 'bytes' | 'rpbbucketprops' | 'rpbcontent' | 'rpbindexreq_indexquerytype' | 'rpblink' | 'rpbpair' | 'uint32'>
riak_kv_pb.erl:171: The pattern <Types, [{Fnum, Bytes} | Tail], Acc> can never match the type <_,[],[{_,_}]>
riak_search_pb.erl:52: The pattern <Default, _> can never match since previous clauses completely covered the type <_,'none'>
riak_search_pb.erl:53: The pattern <Val, _> can never match since previous clauses completely covered the type <_,'none'>
riak_search_pb.erl:59: The pattern <_, 'repeated_packed', 'undefined', _, _> can never match the type <1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10,'optional' | 'repeated' | 'required',_,'bytes' | 'float' | 'rpbpair' | 'rpbsearchdoc' | 'uint32',[[binary() | maybe_improper_list(any(),binary() | [])]]>
riak_search_pb.erl:60: The pattern <_, 'repeated_packed', [], _, _> can never match the type <1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10,'optional' | 'repeated' | 'required',_,'bytes' | 'float' | 'rpbpair' | 'rpbsearchdoc' | 'uint32',[[binary() | maybe_improper_list(any(),binary() | [])]]>
riak_search_pb.erl:71: The pattern <FNum, 'repeated_packed', Data, Type, _> can never match the type <1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10,'optional' | 'repeated' | 'required',_,'bytes' | 'float' | 'rpbpair' | 'rpbsearchdoc' | 'uint32',[[binary() | maybe_improper_list(any(),binary() | [])]]>
riak_search_pb.erl:86: The call riak_search_pb:enum_to_int(Type::'bytes' | 'float' | 'rpbpair' | 'rpbsearchdoc' | 'uint32',Data::atom()) will never return since it differs in the 1st argument from the success typing arguments: ('pikachu','value')
riak_search_pb.erl:88: The pattern <'pikachu', 'value'> can never match the type <'bytes' | 'float' | 'rpbpair' | 'rpbsearchdoc' | 'uint32',atom()>
riak_search_pb.erl:151: The pattern <Binary, 'string'> can never match the type <'-infinity' | 'false' | 'infinity' | 'nan' | 'true' | binary() | [integer()] | number(),'bytes' | 'float' | 'rpbpair' | 'rpbsearchdoc' | 'uint32'>
riak_search_pb.erl:171: The pattern <Types, [{Fnum, Bytes} | Tail], Acc> can never match the type <_,[],[{_,_}]>
riak_core_pb.erl:52: The pattern <Default, _> can never match since previous clauses completely covered the type <_,'none'>
riak_core_pb.erl:53: The pattern <Val, _> can never match since previous clauses completely covered the type <_,'none'>
riak_core_pb.erl:55: The pattern <_, 'optional', 'undefined', _, _> can never match the type <1 | 2 | 3,'required',_,'bytes',[]>
riak_core_pb.erl:57: The pattern <_, 'repeated', 'undefined', _, _> can never match the type <1 | 2 | 3,'required',_,'bytes',[]>
riak_core_pb.erl:59: The pattern <_, 'repeated_packed', 'undefined', _, _> can never match the type <1 | 2 | 3,'required',_,'bytes',[]>
riak_core_pb.erl:60: The pattern <_, 'repeated_packed', [], _, _> can never match the type <1 | 2 | 3,'required',_,'bytes',[]>
riak_core_pb.erl:65: The pattern <_, 'repeated', [], _, Acc> can never match the type <1 | 2 | 3,'required',_,'bytes',[]>
riak_core_pb.erl:68: The pattern <FNum, 'repeated', [Head | Tail], Type, Acc> can never match the type <1 | 2 | 3,'required',_,'bytes',[]>
riak_core_pb.erl:71: The pattern <FNum, 'repeated_packed', Data, Type, _> can never match the type <1 | 2 | 3,'required',_,'bytes',[]>
riak_core_pb.erl:86: The call riak_core_pb:enum_to_int(Type::'bytes',Data::atom()) will never return since it differs in the 1st argument from the success typing arguments: ('pikachu','value')
riak_core_pb.erl:88: The pattern <'pikachu', 'value'> can never match the type <'bytes',atom()>
riak_core_pb.erl:111: The pattern 'true' can never match the type 'false'
riak_core_pb.erl:117: The pattern 'true' can never match the type 'false'
riak_core_pb.erl:126: The pattern 'true' can never match the type 'false'
riak_core_pb.erl:138: The pattern {_, _, Dict} can never match the type 'false'
riak_core_pb.erl:151: The pattern <Binary, 'string'> can never match the type <'-infinity' | 'false' | 'infinity' | 'nan' | 'true' | binary() | [integer()] | number(),'bytes'>
riak_core_pb.erl:171: The pattern <Types, [{Fnum, Bytes} | Tail], Acc> can never match the type <_,[],[{_,_}]>
